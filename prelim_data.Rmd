---
title: "Preliminary analysis of TX expression data"
output: html_notebook
---
#### Goal
The aim of this analysis is to determine how to determine Y and X expression levels and identify DEGs using population data, with the goal of applying to the eQTL dataset.

```{r}
library(tidyverse, quietly = TRUE)
library(vroom)
#library(fread)
library(data.table, quietly = TRUE)
```

#### Pangene annotations from GENESPACE
- using TX maker annotation (prev. version used lifted over from NC)
- allows us to find hemizygous genes, look at gene loss etc. more accurately
- pgMAT and PAT annotations contain the same homologs, so doesn't matter which file to use
- suggestion from stephen: keep pairs where there's one NSORTH and no syn orths
```{r}
#pgMat_tx<-read_table("pangenes_tx/tx_mat_pangenes.txt.gz")
pgMat_tx<-vroom("pangenes_tx/tx_mat_pangenes.txt.gz",show_col_types = FALSE)
#pgPat_tx<-read_table("pangenes_tx/tx_pat_pangenes.txt.gz")

pgMat_PASS<-filter(pgMat_tx,(flag == "PASS") & (genome == "tx_mat"|genome == "tx_pat")) %>%
   select(pgID,genome,id,chr,start, end, flag) %>% 
   group_by(pgID,genome,flag) %>% 
   filter(n() == 1) %>% 
   ungroup() %>%
   distinct() %>%
   pivot_wider(names_from = genome, values_from = c(id,chr,start,end,flag)) %>% 
   #filter(!is.na(id_tx_pat)) %>% filter(!is.na(id_tx_mat)) %>%
   filter(chr_tx_mat == "X" & chr_tx_pat == "Y") %>%
   mutate(across(.cols = c("id_tx_pat","id_tx_mat"), 
                 ~str_replace(.,"-RA$",""))) %>%
   unite(pairID, c("id_tx_mat", "id_tx_pat"),remove = FALSE) %>%  distinct()

#pgMatWide_PASS<- pgMat_PASS %>% distinct() %>% pivot_wider(names_from = genome, values_from = c(id,chr,start,end,flag)) #%>%
 #select(-pgID)

#pgMatGenes_PASS<- pgMatWide_PASS %>% filter(chr_tx_mat == "X" & chr_tx_pat == "Y") %>%
#  mutate(across(.cols = c("id_tx_pat","id_tx_mat"), 
#                 ~str_replace(.,"-RA$",""))) %>%
#  unite(pairID, c("id_tx_mat", "id_tx_pat"),remove = FALSE) %>%  distinct() 

pgIDs_PASS<- select(pgMat_PASS, pgID)


pgMat_NSOrths<-filter(pgMat_tx,(flag == "PASS" & genome == "tx_mat") |(flag =="NSOrtho" & genome == "tx_pat")) %>%
   select(pgID,genome,id,chr,start, end, flag) %>% 
   group_by(pgID,genome,flag) %>% 
   filter(n() == 1) %>% 
   filter(!pgID%in%pgIDs_PASS$pgID) %>%
   ungroup() %>% distinct() %>% 
   pivot_wider(names_from = genome, 
   values_from = c(id,chr,start,end,flag)) %>%
   filter(!is.na(id_tx_pat)) %>% filter(!is.na(id_tx_mat)) %>%
   filter(chr_tx_mat == "X" & chr_tx_pat == "Y") %>%
   mutate(across(.cols = c("id_tx_pat","id_tx_mat"), 
                ~str_replace(.,"-RA$",""))) %>%
   unite(pairID, c("id_tx_mat", "id_tx_pat"),remove = FALSE) %>%  distinct()

dim(pgMat_PASS) #2320 genes
dim(pgMat_NSOrths) # 343 NSorths

#pgMatWide_NSO<- pgMat_NSOrths %>% distinct() %>% 
#  pivot_wider(names_from = genome, 
#  values_from = c(id,chr,start,end,flag)) %>%
#  filter(!is.na(id_tx_pat)) %>% filter(!is.na(id_tx_mat))
  #select(-pgID)
# 2886 NSorths

pgMatOrths<-bind_rows(pgMat_PASS,pgMat_NSOrths) %>% select(-pgID)


```

## population data - josh pop
# summarize and such
```{r}
jpop_reads<-read_table("readCounts/jpopTXmerged.txt") 

colnames(jpop_reads)
colnames_new <- str_replace(colnames(jpop_reads), 
                            "Aligned.sortedByCoord.out", '') %>% 
                 str_replace(., "\\d{1,2}\\.","")

colnames(jpop_reads) <- colnames_new 


# unnormalized read counts okkkkk
# deal with later
jpop_x<- filter(jpop_reads, grepl("X",Chr)) %>% select(c(1,6:18))
jpop_y<- filter(jpop_reads, grepl("Y",Chr)) %>% select(1,6:18)
reads_pg_jpop<-left_join(pgMatOrths,jpop_x, by = c("id_tx_mat"="Geneid")) %>%
  left_join(.,jpop_y, by = c("id_tx_pat" = "Geneid"),suffix = c(".mat",".pat"))
#write_csv(reads_pg_jpop,"reads_pangenes_jpop_TXanno.csv")


jpop_long<- jpop_reads %>% pivot_longer(cols = 7:18, 
               names_to = "sampleName", 
               values_to = "readcount") %>%
  mutate(sex = ifelse(grepl("TM", sampleName), "M", 
               ifelse(grepl("TF", sampleName), "F", NA))) %>%
  mutate(chr = ifelse(grepl("X",Chr), "X",
               ifelse(grepl("Y",Chr), "Y",
               ifelse(grepl("A1",Chr), "A1",
               ifelse(grepl("A2",Chr), "A2",
               ifelse(grepl("A3",Chr), "A3",
               ifelse(grepl("A4",Chr), "A4", NA))))))) %>% select(c(1,6:10))

reads_pg_jpop_long <- left_join(pgMatOrths,jpop_long, by = c("id_tx_mat"="Geneid")) %>%
  left_join(.,jpop_long, by = c("id_tx_pat" = "Geneid","sampleName","sex"),suffix = c(".x",".y"),relationship = "many-to-many")


```
## dist
```{r}
ggplot(reads_pg_jpop_long,aes(x=(readcount.x),y=(readcount.y))) + geom_point(aes(color = sex)) +
  scale_x_continuous(trans='log2') +
  scale_y_continuous(trans='log2') +
  geom_abline(slope = 1, intercept = 0) + 
  geom_smooth(method=lm, se=TRUE, fullrange = TRUE) 

##

ggplot(reads_pg_jpop_long) + geom_histogram(aes(readcount.y, color = sex), bins = 100, position = "stack") +xlim(0,100)

### weird!
jpop_summary <- reads_pg_jpop_long %>% group_by(pairID,sex) %>% summarise(meanCount.x = mean(readcount.x), meanCount.y = mean(readcount.y),nCount.x = sum(readcount.x),nCount.y=sum(readcount.y),propn.x = (nCount.x/(nCount.x+nCount.y)),propn.y = (nCount.y/(nCount.x+nCount.y)) )

genesToRemove<-filter(jpop_summary, propn.x < 0.9 & meanCount.y > 20 & sex == "F")


# ggplot(jpop_summary,aes(x=(meanCount.x),y=(meanCount.y))) + geom_point(aes(color = sex)) +
#   scale_x_continuous(trans='log2') +
#   scale_y_continuous(trans='log2') #+
# ggplot(jpop_summary,aes(x=(nCount.x),y=(nCount.y))) + geom_point(aes(color = sex)) +
#   #scale_x_continuous(trans='log2') +
#   #scale_y_continuous(trans='log2') +
#   geom_abline(slope = 1, intercept = 0) + 
#   geom_smooth(aes(group = sex),method=lm, se=TRUE, fullrange = TRUE) +
#   ylim(0,50000) +
#   xlim(0,50000)

#ggsave("readcountSumBySex.pdf")


  
```


## ok clearly some normalization is needed across all samples/genes
## read in exon counts
actually don't, because we don't know if exon 1 in gene A is the same as exon 1 in gene B (gametolog)
WOMP

Filter out the bad genes with female Y mapping.
```{r}
#jpop_reads_exons<-read_table("readCounts/jpopTXmerged_exon.txt") 

# norm counts


## normalize: quantile distribution, Y- X exp in females, not fair?
# generate norm factors with just the autosomal data

library(DESeq2, quietly = TRUE)


rowdata<- jpop_reads %>% select(Geneid,Chr,Start,End)
read_counts_all <- jpop_reads %>% column_to_rownames(var = "Geneid") %>% select(TM4:TM3)
coldata<- DataFrame(colnames(jpop_reads%>% select(TM4:TM3)))
####
df<-DESeqDataSetFromMatrix(read_counts_all,coldata,design = ~ 1)
dds <- DESeq(df)
#dds<-estimateSizeFactors(dds)
allchrFactors<-sizeFactors(dds)
#norm_counts<-count()

normalized_counts_all<-counts(dds, normalized=TRUE)

### with just autosomes
read_counts_auto<- jpop_reads %>% filter(grepl("A",Chr))%>% column_to_rownames(var = "Geneid") %>% select(TM4:TM3)
df_auto<-DESeqDataSetFromMatrix(read_counts_auto,coldata,design = ~ 1)
dds_auto <- DESeq(df_auto)
autochrFactors<-sizeFactors(dds_auto)

# replace og coutn tabels size factors
dds$sizeFactor<-autochrFactors
dds$sizeFactor

normalized_counts_auto<-counts(dds, normalized=TRUE)
```

Compare expression of hemizygous genes b/w males and females
```{r}
hemizygous<-
```


